* ansible
#+BEGIN_SRC 
 $ansible <system>
-i <inventory file>
-m <module>
-u <username>
-k <passowr prompt>
-v <verbose -vv debug level 2 / -vvv debug level 3)

#+END_SRC

- Change Management

- Provisioning
Transiton from one state to another. Pepare system to be ready
- Automation
Sequence of steps to perform automated
- Orchestration
Coordinates automation between systems

- Why?
No agents
no database
No residual software
No complex upgrades (no external dependencies)

Easy to implement easy to progarm inherently secure. ssh very extensible



Inventory(maps hosts)
||
PlayBook => Ansible Config(configuration sets, ansible parameters) => Python => SSH =>......servers.....
||
Modules (define actions)

- Variables
  - Host Variables
    - User variables, inventory per host or group
  - Facts
    - Use data gathered from remote managed host
  - Dynamic variables
    - use data gathered by tasks or created by runtime

- Control server =(package)=> Remote Servers
- Remote server =(results.json)=> Control Server


* ansible-playbooks

** Ansible playbook some parameters

**** Inventory
ansible-playbook -i hosts main.yaml

**** Host key checking disable

~ansible-playbook -i hosts -e 'host_key_checking=False' main.yaml~

**** Extra params

#+BEGIN_SRC 
ansible-playbook -i hosts -e "host_key_checking=False" main.yaml --extra-vars "deploy_host=${envname}"
#+END_SRC

...and receive it like this in playbook:

#+BEGIN_SRC 
hosts: "{{ deploy_host | default('dev') }}"
#+END_SRC

*** ansible.cfg to configure params
#+BEGIN_SRC 
[defaults]
hostfile = hosts
ansible_connection=local
Add a comment to this line
vault_password_file = vault_pass.py
host_key_checking = False

#+END_SRC

http://docs.ansible.com/ansible/latest/intro_configuration.html

*** copy remote src
#+BEGIN_SRC 
    - name: Unzip WAR file
      unarchive:
        src: "{{ playbook_dir }}/target/{{ warName }}"
        dest: /usr/share/tomcat/webapps/{{project_id}}/ 
        mode: 0755
        remote_src: yes
        owner: tomcat
        group: tomcat
      become: true
#+END_SRC

** Docker, Springboot, Postgresql, Nginx kickstart playbook

#+BEGIN_SRC 
---
- hosts: localhost
  connection: local
  become: true
  gather_facts: true
  vars_files:
    - settings.yaml
  vars:
    proj_name: "devopscicd"
    nginx_host: "devopscicd.xyz.com"
    nginx_port: 80
    dashboard_ui_port: 8092
    dashboard_api_port: 8091
    postgresql_db_port: 5432
  tasks:
  - name: Create the network
    docker_network:
      name: dodashb_network

  - name: build ./nginx/ image  
    docker_image: 
      path: ./dev/docker/webserv/
      name: ddb_webserv

  - name: build ./postgresql/ image  
    docker_image: 
      path: ./dev/docker/postgresql/
      name: postgresql_db

  - name: build ./nginx/ image  
    docker_image: 
      path: ./dev/docker/nginx/
      name: ddb_nginx

  - name: build ./dashboard-api/ image  
    docker_image: 
      path: ./dev/docker/dashboard-api/
      name: dashboard-api

  - name: start postresql_db container
    docker_container:
      name: postgresql_db
      image: postgresql_db
      volumes:
        - ./postgresql/db:/var/lib/postgresql/data
      ports:
        - "5432:5432"
      env:
        DEBUG: "false"
        POSTGRES_USER: "sa"
        POSTGRES_PASS: "password"
        POSTGRES_DB: "devopscicd_db"
      state: "started"
      restart: "yes"
      networks:
        - name: dodashb_network

  - name: start dashboard-api container
    docker_container:
      name: dashboard-api
      image: dashboard-api
      volumes:
        - ./dashboard-api/logs:/opt/logs
        - ./dashboard-api/app:/opt/target
      ports:
        - "8091:8091"
      links:
        - postgresql_db
      networks:
        - name: dodashb_network
      state: "started"
      restart: "yes"

  - name: run dashboard_ui container
    docker_container:
      name: dashboard_ui
      image: ddb_webserv
      volumes:
        - ./dashboard/app:/var/www
      ports:
        - "8092 : 80"
      networks:
        - name: dodashb_network
      state: "started"
      restart: "yes"

  - name: start nginx container
    docker_container:
      name: ddb_nginx_webserv
      image: ddb_nginx
      volumes:
        - ./ddb_nginx/app:/var/www
      ports:
        - "80 : 80"
      networks:
        - name: dodashb_network
      state: "started"
      restart: "yes"

#+END_SRC


** Probe host 

#+BEGIN_SRC 
---
- name: Probe a system until it is up
  hosts: localhost
  connection: local
  gather_facts: no
  vars:
    probe_host: "{{ probe_host | default('dev.devakthk.ddns.net') }}"
    probe_port: "{{ probe_port | default('80') }}"
    probe_delay: "{{ probe_delay | default('0') }}"
    probe_timeout: "{{ probe_timeout | default('180') }}"
  tasks:
  - name: Message
    debug: 
      msg: >
        Probing {{ probe_host }}:{{ probe_port }} with delay={{ probe_delay }}s
        and timeout={{ probe_timeout}}s
  - name: Waiting for host to respond...
    local_action: >
      wait_for host={{ probe_host }}
      port={{ probe_port }}
      delay={{ probe_delay }}
      timeout={{ probe_timeout }}

#+END_SRC

** List s3 buckets

#+BEGIN_SRC 
- hosts: localhost
  connection: local
  vars:
    s3_bucket_name: mybucket-repo
    project_id: auth-api
  tasks:
    - name: "list all jars in s3 bucket"
      shell: "aws s3 ls --recursive s3://{{s3_bucket_name}}/{{project_id}} | grep '.*\\.jar$' | awk -F \" \" '{print $4}'"
      register: resp
    - debug: var=resp

    - name: "list the latest jar in s3 bucket"
      shell: "aws s3 ls s3://{{s3_bucket_name}}/{{project_id}}/ --recursive | sort | tail -n 1 | awk -F \" \" '{print $4}'"
      register: resp
    - debug: var=resp
#+END_SRC
