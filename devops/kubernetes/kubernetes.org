* kubernetes
** minikube start
minikube start --vm-driver="hyperv" --hyperv-virtual-switch="Default Switch"  
kubectl get nodes

minikube dashboard
** kubectl
#+BEGIN_SRC 
sudo wget https://storage.googleapis.com/kubernetes-release/release/v1.0.1/bin/linux/amd64/kubectl
sudo chmod +x kubectl
sudo mv kubectl /usr/local/bin/.
#+END_SRC

** pods
kubectl get nodes

=====
#pod.yaml

apiVersion: v1
kind: pod
metadata:
  name: hello-pod
spec:
  containers:
    - name: hello-ctr
      image: amitthk/angdnx
      ports:
        - containerPort: 5000

=====


kubectl create -f pod.yaml

kubectl get pods

kubectl describe pods

kubectl get pods/hello-pod

kubectl get pods --all-namespaces
** replication controllers

#replc.yaml

apiVersion: v1
kind: ReplicationControler
metadata:
  name: hello-rc
spec:
  reeplicas: 5
  selector:
    app: hello-world
  template:
    metadata:
      labels:
        app: hello-world
    spec:
      containers:
      - name: hello-world
        image: amitthk/angdnx
        ports:
          - containerPort: 5000
===

kubectl create -f replc.yaml

===
vi replc.yaml

replicas: 10
===

kubectl apply -f replc.yaml

kubectl get rc

kubectl get rc -o wide

kubectl get pods
** services

kubectl expose rc hello-rc --name=hello-svc --targetPort=8080 --type=NodePort
kubectl describe svc hello-svc

# IP is virtual ip, NodePort is expose port


====
#vi hello-svc.yaml

apiVersion: v1
kind: Service
metadata:
  name: hello-svc
  labels:
    app: hello-world
spec:
  type: NodePort
  ports:
  - port: 8080
    protocol: TCP
  selector:
    app: hello-world
============

ServiceTypes: 

Clusterip :  "stable" internal cluster ip
NodePort:   Expose app outside cluster. Adds cluster-wide port on top of ClusterIP
LoadBalancer: Integrates NodePort with cloud based load balancers
** endpoints

kubectl get ep #endpoints
** deployments

deployments => replica-sets => pods => containers

kubectl rolling-update -f updated-rc.yml

=======
#vi depl.yml

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: hello-deployment
spec:
  replicas: 10
  template:
    metadata:
      labels:
        app: hello-world
    spec:
      containers:
      - name: hello-pod
        image: amtithk/angdnx
        ports:
        - containerPort: 5000
==========

kubectl create -f depl.yml
kubectl describe deploy hello-deployment

====update===
#vi depl.yml
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
..... 
      image: amitthk/angdnx:0.0.2
========
*** rollout updated deployment

kubectl apply -f depl.yml --record
kubectl rollout status deployment hello-deployment
kubectl rollout history deployment hello-deployment
*** rollback to previous replca set
kubectl rollout undo deployment hello-deploy --to-revision=1

=========

** healthchecks

*** livenessprobe

#+BEGIN_SRC 
containers:
- name: xyz
  ...
  livenessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 15
    timeoutSeconds: 30

#+END_SRC

*** readinessprobe

#+BEGIN_SRC 
containers:
- name: xyz
  ...
  livenessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 15
    timeoutSeconds: 30
  readinessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 15
    timeoutSeconds: 30
#+END_SRC

*** pod status, pod condition, container state

**** pod state
Pending - downloading image, resource constr
Succeeded - all containers terminated and wont be restarted
Failed - terminated containers. failiure code is exit code of process when ctr stops
Unknown - cannot be determined e.g. network error

**** pod conditions
pod scheduled
ready - ready to serve req. and will be added to svc 
initialized - initiz cntnrs started successfully
unschedulable - pod can't be scheduled
containersready

| Init container => | post start hook ==> | readiness probe, liveness probe ==> | pre stop hook |

** monitoring
heapster, influxdb, grafana

** run k8s locally using docker

#+BEGIN_SRC 

docker run --net=host -d gcr.io/google_containers/etcd:2.0.9 /usr/local/bin/etcd --addr=127.0.0.1:4001 --bind-addr=0.0.0.0:4001 --data-dir=/var/etcd/data

 

docker run --net=host -d -v /var/run/docker.sock:/var/run/docker.sock  gcr.io/google_containers/hyperkube:v0.21.2 /hyperkube kubelet --api_servers=http://localhost:8080 --v=2 --address=0.0.0.0 --enable_server --hostname_override=127.0.0.1 --config=/etc/kubernetes/manifests

 

docker run -d --net=host --privileged gcr.io/google_containers/hyperkube:v0.21.2 /hyperkube proxy --master=http://127.0.0.1:8080 --v=2

#+END_SRC 

*** Running an application

kubectl -s http://localhost:8080 run-container nginx --image=nginx --port=80

*** Expose it as a service

kubectl expose rc nginx --port=80

*** Turn down cluster

docker ps -a | awk '{print $1}' | xargs docker kill

 

*** Docker
Show available images

docker images

*** Build image

docker build -t approdorix/appname .

*** Stop, remove containers/images

docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
docker rmi $(docker images -q) 

 

*** Troubleshooting docker
You want to run screen but no tty in docker:
exec >/dev/tty 2>/dev/tty </dev/tty

** install gcloud sdk

#+BEGIN_SRC 
sudo tee -a /etc/yum.repos.d/google-cloud-sdk.repo << EOM
[google-cloud-sdk]
name=Google Cloud SDK
baseurl=https://packages.cloud.google.com/yum/repos/cloud-sdk-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
       https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOM

#+END_SRC
   
~sudo yum install google-cloud-sdk

